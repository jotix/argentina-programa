* Ejercicio 8:
Escriba una función que, dado un número de DNI, retorne True
si el número es válido y False si no lo es. Para que un número de DNI
sea válido debe tener entre 7 y 8 dígitos en base 10. Luego escriba un
programa que pruebe la función.
#+begin_src python

#+end_src

* Ejercicio 9:
Implemente un padrón de personas. Por cada persona se al-
macena el nombre, dni y domicilio. El programa debe permitir que el
usuario pueda:
1. Incorporar personas al padrón.
2. Eliminar personas del padrón.
3. Modificar los datos de una persona en el padrón.
4. Imprimir por pantalla los datos de una persona específica.
El programa debe mostrar por pantalla un menú de opciones con los
ítems descritos anteriormente. El programa finalizará si el usuario in-
gresa como opción un 0.
#+begin_src python

#+end_src

* Ejercicio 10
Construya una función que reciba como parámetro dos valores
si esos valores son enteros la función retorna como resultado la suma
de dichos valores. Si los valores son strings la función retorna como
resultado la concatenación de los strings. En otro caso la función dispara
una excepción ValueError.
#+begin_src python

#+end_src

* Ejercicio 11:
Defina la función porcentaje la cual recibe como parámetro
una lista de números flotantes l y un número entero p. La función
retorna como resultado el porcentaje p de la suma de los elementos de
l. La función recibe como parámetro por defecto la lista vacía.
#+begin_src python

#+end_src

* Ejercicio 12:
Implemente las siguientes funciones:
- Factorial(n)= 1 × 2 × 3 × ..... × n − 1 × n
- Fibonacci(n) la cual se define como sigue:
-- Fibonacci(0)=0
-- Fibonacci(1)=1
-- Fibonacci(n)=Fibonacci(n-1)+Fibonacci(n-2).
-Potencia(n,m)=nm
Luego construya un programa principal que permita probar las funciones.
Esto es invocarlas con argumentos correctos e incorrectos. Maneje
los errores que surgen por la invocación de argumentos incorrectos con
excepciones.
#+begin_src python :tangle 12.py
# ineficiente en uso de memoria
def factorial(n):
    if n <= 1:
        return n
    else:
        return n * factorial(n-1)

# factorial optimizado con recursión de cola
# (usa menos memoria)    
def factorial2(n, a=1):
    if n <= 1:
        return a
    return factorial2(n-1, n*a)
    
# muy ineficiente, tarda demasiado con n>30    
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# fibonacci optimizada con un cache
# (es mucho mas eficiente en tiempo de ejecución)
fib_array = [0, 1]    
def fibonacci2(n):
    if n < len(fib_array):
        return fib_array[n]
    fib_array.append(fibonacci2(n-1) + fibonacci2(n-2))
    return fib_array[n]

n = int(input("Ingrese un número entero: "))
print("Factorial de", n, "es", factorial(n))
print("Factorial2 de", n, "es", factorial2(n))
#print("Fibonacci de", n, "es", fibonacci(n))
print("Fibonacci2 de", n, "es", fibonacci2(n))
#+end_src
